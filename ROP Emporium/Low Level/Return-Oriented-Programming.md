> ROP is used to attack against W^X (W xor X) in other words non-executable stack (NX bit) which disables code execution from stack.
> 
> The concept of ROP is to utilize small instruction sequences available in either the binary or libraries linked to the application called gadgets. So, instead of returning to a libc function (like in ret2libc) we will be returning to these ROP gadgets.

```c
#include <stdio.h>
#include <string.h>

void rop1(int a, int b, int c) {
	do_something();
}
void rop2(int a, int b, int c) {
	do_something();
}

int main(int argc, char** argv) {
	char buffer[100];
	strcpy(buffer, argv[1]);
	
	return 0;
}
```

Let's say we want the program above to run `rop1` -> `rop2` . The payload would be as follows:
## 32 bit
gadget = `pop pop pop ret;`. Doesn't matter what register we use in the gadget since we only want to free the stack so `ret` can jump to the next address.
```bash
| padding | addr rop1() | gadget | param1-3 | addr rop2() | gadget | param1-3 |
```
## 64 bit
Since in 64 bit, The 3 parameters would need to be stored at `RDI`, `RSI`, and `RDX` ([[Return-to-libc attack#^0198bd | see why]]). Thus, we need to find or construct a gadget that satisfy those requirements. Say, we're using `pop rdi; pop rsi; pop rdx; ret;` as gadget and since we can use the same gadget more than once, this is the only gadget that we need.

```bash
| padding | gadget | param1-3 | addr rop1() | gadget | param1-3 | addr rop2() |
```

---
### Resources
* [ROP Chaining: Return Oriented Programming - Red Teaming Experiments (ired.team)](https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/rop-chaining-return-oriented-programming)
* [28479-return-oriented-programming-(rop-ftw).pdf (exploit-db.com)](https://www.exploit-db.com/docs/english/28479-return-oriented-programming-(rop-ftw).pdf)