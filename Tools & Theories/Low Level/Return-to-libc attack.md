> Return-to-libc is an attack to **bypass stack protected (NX) program** by subverting the program flow using the existing executable code from the standard C library shared object (/lib/i386-linux-gnu/libc-*.so).
>
> The basic idea is similar to buffer overflow but instead of pointing eip to our shellcode, we want to redirect eip to a libc function and execute our instruction from there (dropping a shell or reading a file or what have you). 

Because of how the stack is structured, we can generalize ret2libc payload as follows:
## 32 bit
In x86 (32-bit), function parameters are passed on the stack.
```bash
buffer + libc addr + libc return addr + addr of param
```

^77982f

```bash
# for dropping a shell
buffer + addr of system() + addr of exit() + addr of /bin/sh 
```
Where:
1. <span class=red>Buffer</span> -> junk data until we hit return address.
2. <span class=red> libc addr</span> -> the address of the libc function, i.e: `system()`, `execv()`, etc. 
3. <span class=red>libc return addr</span> -> return address for the libc function. Usually this will be the address of `exit()` to finish our program gracefully (without error messages).
4. <span class=red>addr of param</span> -> address for the string that is used as the argument for the libc function.
## 64 bit

^119a44

In 64-bit binaries, the first 6 function parameters are passed in registers `RDI`, `RSI`, `RDX`, `RCX`, `R8`, and `R9`. Anything beyond that is passed in the stack. ^0198bd

This means that before returning to our function of choice in libc, we need to make sure the registers are setup correctly with the parameters the function is expecting. This means that we need to do a little bit of [[Return-Oriented-Programming]] ^63a3c6

```bash
buffer + gadget + addr of param + addr of libc func
```

Since we're only using one parameter, we only need to find a gadget that place our parameter in `RDI`, which is `pop RDI; ret;` . That gadget will pop the value off the stack (which will be the address of our parameter) and place it on `RDI` and return to the `addr of libc func`. The libc function will then run **with** the parameter that we have placed before in `RDI`.

To find a gadget you can use [[Cheat Sheet#^abf07f| Ropper]].

---
## How do we find each address?
* You can find strings inside of the program such as `/bin/sh` using these [[Cheat Sheet#^092aa9| commands]].
* You can find the location of a function such as `system()` using these [[Cheat Sheet#^f304b6| commands]].

---
## What if the address of libc function contains \x00?

---
## What if we want to chain multiple functions? (see ref no. 4)

---
### References
* [Return-to-libc By Saif El-Sherei](https://www.exploit-db.com/docs/english/28553-linux-classic-return-to-libc-&-return-to-libc-chaining-tutorial.pdf)
* [Return-to-libc / ret2libc - Red Teaming Experiments (ired.team)](https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/return-to-libc-ret2libc)
* [64-bit Linux stack smashing tutorial: Part 2 – Techorganic – Musings from the brainpan](https://blog.techorganic.com/2015/04/21/64-bit-linux-stack-smashing-tutorial-part-2/)
* [.:: Phrack Magazine ::.](http://phrack.org/issues/58/4.html)